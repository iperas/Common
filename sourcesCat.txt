{DatabaseWriter.h}

#ifndef DatabaseWriter_h__
#define DatabaseWriter_h__

#include <QtCore/QtCore>
#include <QtSql/QtSql>
#include <memory>
#include "Common/Exceptions/DatabaseException.h"
#include "Common/Database/DatabaseHelper.h"
#include "Common/Settings/Settings.h"
#include "Common/Log/Log.h"
#include "Common/Database/DataInserter.h"
#include "Common/Database/Connection.h"
#include "JpsFile.h"

using Greis::JpsFile_t;

class DatabaseWriter
{
private:
    bool _connected;
    Connection _connection;
    DatabaseHelper* _dbHelper;
    QMap<QString,QString> _columnsMap;
    int _dataSourceId;
    QString _unixTimeColumn;
    QString _dataTable;
    double _maxDateTime;
public:
    DatabaseWriter()
    {
        _unixTimeColumn = "UT";
        _connected = false;
    }

    inline double MaxDateTime() const { return _maxDateTime; }

    void Connect(const Connection& ci, const QString& sourceName)
    {
        _connection = ci;
        _connection.Connect();
        _dbHelper = _connection.DbHelper();
        
        /* reading structure */
        // dataTable name
        _dataSourceId = _dbHelper->ExecuteSingleValueQuery(QString("SELECT Id FROM DataSource WHERE Name = '%1'").arg(sourceName)).toInt();
        _dataTable = _dbHelper->ExecuteSingleValueQuery(QString("SELECT DataTable FROM DataSource WHERE Id = %1").arg(_dataSourceId)).toString();
        // columns mapping
        QSqlQuery query = _dbHelper->ExecuteQuery(QString("SELECT RawDataColumnName, DataTableColumnName FROM Channel WHERE DataSourceId = %1").arg(_dataSourceId));
        while(query.next())
        {
            QString rawDataColumn = query.value(0).toString();
            QString tableColumn = query.value(1).toString();
            _columnsMap[rawDataColumn] = tableColumn;
        }
        // maxDateTime
        _maxDateTime = 0;
        if (_dbHelper->ExecuteSingleValueQuery(QString("SELECT COUNT(*) FROM %2").arg(_dataTable)).toInt() > 0)
        {
            _maxDateTime = _dbHelper->ExecuteSingleValueQuery(QString("SELECT MAX(%1) FROM %2").
                arg(_columnsMap[_unixTimeColumn]).arg(_dataTable)).toDouble();
        }

        _connected = true;
    }

    void AddData(JpsFile_t::Pointer_t jpsFile)
    {
        sLog.addInfo(QString("Добавление данных из источника '%1' в базу данных...").arg(jpsFile->filename()));
        /*QVector<QString> insertingColumns;
        QVector<int> insertingIndexes;
        int unixTimeColumnIndex;

        // если нечего добавлять, выход
        if (table->Rows.count() == 0)
        {
            sLog.addWarning(QString("В источнике '%1' нет строк для добавления.").arg(table->Name));
            return;
        }
        if (table->Rows.first().count() == 0)
        {
            sLog.addWarning(QString("В источнике '%1' нет стобцов.").arg(table->Name));
            return;
        }

        // Определение столбцов
        int index = 0;
        foreach(string rawDataColumnStr, table->Columns)
        {
            QString rawDataColumn = QString::fromStdString(rawDataColumnStr);
            if (!_columnsMap.contains(rawDataColumn))
            {
                sLog.addWarning(QString("Столбец исходных данных %1 источника '%2' не найден в описании источника.").arg(rawDataColumn).arg(table->Name));
            } else {
                if (rawDataColumn == _unixTimeColumn)
                {
                    unixTimeColumnIndex = index;
                }
                insertingColumns.push_back(_columnsMap[rawDataColumn]);
                insertingIndexes.push_back(index++);
            }
        }

        // Выход если их нет
        if (insertingColumns.count() == 0)
        {
            sLog.addWarning(QString("В источнике '%1' не найдено столбцов с данными для добавления.").arg(table->Name));
            return;
        }

        // шаблон для инсерта
        QString insertTemplate(QString("INSERT INTO %1(").arg(_dataTable));
        foreach(QString colHeader, insertingColumns)
        {
            insertTemplate.append(colHeader);
            insertTemplate.append(", ");
        }
        insertTemplate.remove(insertTemplate.count() - 2, 2);
        insertTemplate.append(") VALUES ");

        DataInserter dataInserter(insertTemplate, &_connection);

        // выборка по времени
        int rowsCountInDb = _dbHelper->ExecuteSingleValueQuery(QString("SELECT count(*) FROM %1").arg(_dataTable)).toInt();
        bool truncateEnabled = rowsCountInDb > 0; // таблица не пуста, требуется игнорировать входные данные, если они внутри интервала базы
        double startTimeInDb;
        double endTimeInDb;
        if (truncateEnabled)
        {
            startTimeInDb = _dbHelper->ExecuteSingleValueQuery(QString("SELECT min(%1) FROM %2").arg(_columnsMap.value(_unixTimeColumn)).arg(_dataTable)).toDouble();
            endTimeInDb = _dbHelper->ExecuteSingleValueQuery(QString("SELECT max(%1) FROM %2").arg(_columnsMap.value(_unixTimeColumn)).arg(_dataTable)).toDouble();
        }
        for(QVector< QVector<double> >::const_iterator row = table->Rows.constBegin(); row != table->Rows.constEnd(); ++row)
        {
            double rowTime = (*row)[unixTimeColumnIndex];
            // -----------************---------- <- данные в базе
            // --------------------+------------ <- строка из базы
            if (truncateEnabled && rowTime <= endTimeInDb && rowTime >= startTimeInDb)
            {
                continue;
            }

            QString insertDataLine("(");
            insertDataLine.reserve(500);
            for (QVector<int>::iterator value = insertingIndexes.begin(); value != insertingIndexes.end(); ++value)
            {
                insertDataLine.append(QString("%1, ").arg((*row)[*value], 0, 'f'));
            }
            insertDataLine.remove(insertDataLine.count() - 2, 2);
            insertDataLine.append(")");
            
            dataInserter.AddRow(insertDataLine);
        }
        dataInserter.Flush();*/
        sLog.addInfo(QString("...завершено."));
    }
};

#endif // DatabaseWriter_h__

{GreisChecksum.h}

#ifndef GreisChecksum_h__
#define GreisChecksum_h__

#include "GreisTypes.h"

namespace Greis
{
    class ChecksumChecker
    {
        // 8-bit checksum
    private:
        enum 
        {
            bits = 8,
            lShift = 2,
            rShift = bits - lShift
        };

        static inline Types::u1 ROT_LEFT(Types::u1 val) { return ((val << lShift) | (val >> rShift)); }
        //static inline Types::u1 ROT_LEFT(Types::u1 val) { return val; }

    public:
        static Types::u1 cs8(void const* source, int count, Types::u1 initVal = 0)
        {
            Types::u1 const* src = (Types::u1 const*)source;
            // empty array
            if (count == 0)
            {
                return initVal;
            }
            // initialize
            Types::u1 res = 0;
            if (initVal != 0)
            {
                // ROT_LEFT was on previous step (in return statement)
                res = initVal ^ *src++;
                --count;
            }
            // act
            while(count--)
                res = ROT_LEFT(res) ^ *src++;
            return ROT_LEFT(res);
        }

        // 16-bit CRC
        typedef unsigned short Crc16;

    private:
        enum
        {
            WIDTH = 16,                     // Width of poly
            POLY = 0x1021,                  // Poly. Bit #16 is set and hidden
            BYTE_BITS = 8,                  // Number of bits in byte
            TABLE_SIZE = 1 << BYTE_BITS,    // Size of table
            MSB_MASK = 1 << (WIDTH - 1)     // Mask for high order bit in a word
        };

        // Table (generated by 'crc16init()')
        static Crc16* table()
        {
            static Crc16 aTable[TABLE_SIZE];
            static bool firstCall = true;
            if (firstCall)
            {
                crc16init(aTable);
                firstCall = false;
            }
            return aTable;
        }

        // Initializes the table. Should be called once before the first
        // call to 'crc16()'
        static void crc16init(Crc16* table)
        {
            Crc16 i;
            for(i = 0; i < TABLE_SIZE; ++i)
            {
                Crc16 val = i << (WIDTH - BYTE_BITS);
                int j;
                for(j = 0; j < BYTE_BITS; ++j)
                    val = (val << 1) ^ ((val & MSB_MASK) ? POLY : 0);
                table[i] = val;
            }
        }

    public:
        // Calculates CRC16 of 'cnt' bytes from 'src' and returns result.
        // Initial value of CRC16 is supplied by caller in 'crc'.
        static Crc16 crc16(void const* src, int cnt, Crc16 crc = 0)
        {
            unsigned char const* s = (unsigned char const*)src;
            while(cnt--)
            {
                crc = (crc << BYTE_BITS) ^ table()[(crc >> (WIDTH - BYTE_BITS)) ^ *s++];
            }
            return crc;
        }
    };
}

#endif // GreisChecksum_h__

{GreisException.h}

#ifndef GreisException_h__
#define GreisException_h__

#include <QtCore/QtCore>
#include "Common/Exceptions/Exception.h"

namespace Greis
{
    class GreisException : public Exception
    {
    public:
        GreisException(const QString& message) : Exception(message)
        {
        }
    };
}

#endif // GreisException_h__

{GreisMessage.h}

#ifndef GreisMessage_h__
#define GreisMessage_h__

#include "Common/Util/macros.h"
#include "Common/Util/commonBoost.h"
#include "Common/Exceptions/InvalidOperationException.h"
#include <cassert>
#include <string>
#include <vector>
#include <map>
#include <boost/algorithm/string.hpp>
#include "GreisTypes.h"
#include "GreisChecksum.h"

using std::string;
using std::vector;
using std::map;

namespace stringBoost = boost::algorithm;

#pragma pack (push, 1)

#define CHAR2_TO_USHORT(c_id) ((((unsigned short)(c_id)[0]) << 8) | (c_id)[1])

namespace Greis
{
    enum EMessageType
    {
        NonStdTextMessage,
        UnknownStdMessage,
        JPStdMessage,
        MFStdMessage,
        RTStdMessage
    };

    class Message_t
    {
    private:
        const EMessageType _type;
    public:
        SHARED_PTR_T(Message_t);
        NULL_PTR_DECL;

        Message_t(EMessageType p_type) : _type(p_type)
        {
        }

        virtual string toString() const = 0;
        virtual bool validate() const = 0;

        inline EMessageType type() const { return _type; }
    };

    class NonStdTextMessage_t : public Message_t
    {
    public:
        SHARED_PTR_T(NonStdTextMessage_t);
        NULL_PTR_DECL;

        // Zero-length non-standard Text Message
        NonStdTextMessage_t(char p_eom) : Message_t(NonStdTextMessage)
        {
            id = 0;
            eom = p_eom;
        }

        // Non-standard Text Message
        NonStdTextMessage_t(char p_id, string p_body, char p_eom) : Message_t(NonStdTextMessage)
        {
            id = p_id;
            body = p_body;
            eom = p_eom;
        }

        virtual string toString() const
        {
            string eomStr = eom == '\r' ? "\\r" : (eom == '\n' ? "\\n" : string(1, eom));
            string ret = boost::str(boost::format("<NonStdTextMessage id=0x%1$02X body_length=%2% eom='%3%'>%4%</NonStdTextMessage>") % (int)id % body.size() % eomStr % body);
            return ret;
        }

        virtual bool validate() const
        {
            if (body.size() > 0 && (id < min_id || id > max_id))
                return false;
            if (!isEom(eom))
                return false;
            return true;
        }

        inline static bool isEom(char ch) { return ch == '\r' || ch == '\n'; }

        char id;
        string body;
        char eom;

        static const char min_id = 33;
        static const char max_id = 47;
    };

    class StdMessage_t : public Message_t
    {
    public:
        SHARED_PTR_T(StdMessage_t);
        NULL_PTR_DECL;

        StdMessage_t(char* p_message, int p_length)
            : Message_t(UnknownStdMessage), _message(p_length)
        {
            memcpy(&_message[0], p_message, p_length);
        }

        virtual string toString() const
        {
            return toString("StdMessage");
        }

        virtual bool validate() const
        {
            string aId = id();
            if (aId[0] < min_id_char || aId[0] > max_id_char || 
                aId[1] < min_id_char || aId[1] > max_id_char)
                return false;
            return true;
        }

        inline string id() const { return string(&_message[0], 2); }
        inline static int headSize() { return _headSize; }
        inline int bodySize() const { return _message.size() - _headSize; }
        inline int fullSize() const { return headSize() + bodySize(); }
        inline const char* body() const
        {
            if (bodySize() == 0)
                throw InvalidOperationException();
            return &_message[_headSize];
        }
        inline const char* message() const { return &_message[0]; }

        static const char min_id_char = 48;
        static const char max_id_char = 126;

    protected:
        StdMessage_t(char* p_message, int p_length, EMessageType p_msgType)
            : Message_t(p_msgType), _message(p_length)
        {
            memcpy(&_message[0], p_message, p_length);
        }

        string toString(const string& tagName) const
        {
            string ret = boost::str(boost::format("<%1% id='%2%' body_length=%3%>%4%</%1%>") % tagName % id() % bodySize() % bodyToString());
            return ret;
        }

        // Переопределить в потомках для корректного отображения содержимого в toString(tagName)
        virtual string bodyToString() const
        {
            string ret;
            for (vector<char>::const_iterator it = _message.begin() + 5; it != _message.end(); ++it)
            {
                char ch = *it;
                if (isprint((unsigned char)ch))
                {
                    ret.push_back(ch);
                }
                else
                {
                    ret.append(boost::str(boost::format("{0x%1$02X}") % (unsigned int)(unsigned char)ch));
                }
            }
            return ret;
        }

        bool validateChecksum8ascii() const
        {
            // expected
            if (bodySize() <= 2)
                throw Exception("Body too small.");
            bool bOk;
            Types::u1 expected = QString::fromAscii(body() + bodySize() - 2, 2).toUInt(&bOk, 16);
            if (!bOk)
                return false;
            // actual
            Types::u1 actual = ChecksumChecker::cs8(&_message[0], _headSize + bodySize() - 2);
            /*Types::u1 actual = ChecksumChecker::cs8(_id.c_str(), 2);
            actual = ChecksumChecker::cs8(_bodyLenStr.c_str(), 3, actual);
            if (bodySize() > 2)
                actual = ChecksumChecker::cs8(body(), bodySize() - 2, actual);*/
            // check
            return expected == actual;
        }

        bool validateChecksum8bin() const
        {
            // expected
            if (bodySize() <= 1)
                throw Exception("Body too small.");
            Types::u1 expected = ((Types::u1*)body())[bodySize() - 1];
            // actual
            Types::u1 actual = ChecksumChecker::cs8(&_message[0], _headSize + bodySize() - 1);
            /*Types::u1 actual = ChecksumChecker::cs8(_id.c_str(), 2);
            actual = ChecksumChecker::cs8(_bodyLenStr.c_str(), 3, actual);
            if (bodySize() > 2)
                actual = ChecksumChecker::cs8(body(), bodySize() - 1, actual);*/
            // check
            return expected == actual;
        }

    private:
        vector<char> _message; // Id&Len&Body
    protected:
        static const int _headSize = 5;
    };

    /*********************** General Purpose Messages **************************/

    // File Identifier
    class JPStdMessage_t : public StdMessage_t
    {
    public:
        SHARED_PTR_T(JPStdMessage_t);
        NULL_PTR_DECL;

        JPStdMessage_t(char* p_message, int p_length) : StdMessage_t(p_message, p_length, JPStdMessage),
            _fileTypeId(p_message + _headSize, 5),
            _description(p_message + _headSize + 5, p_length - 5 - _headSize)
        {
            stringBoost::trim(_description);
        }

        virtual string toString() const
        {
            return StdMessage_t::toString("JPStdMessage");
        }

        virtual bool validate() const
        {
            bool good = StdMessage_t::validate() && 
                        bodySize() == expectedLength && 
                        fileTypeId() == javadGnssId;
            return good;
        }

        inline string fileTypeId() const { return _fileTypeId; }
        inline string description() const { return _description; }

        static const string javadGnssId;
        static const string javadGnssDescriptionFormat;
        static const int expectedLength = 85;
    protected:
        virtual string bodyToString() const
        {
            return fileTypeId() + description();
        }
    private:
        string _fileTypeId; // File type identifier
        string _description; // Human-readable stream description
    };

    // Messages Format
    class MFStdMessage_t : public StdMessage_t
    {
    public:
    	SHARED_PTR_T(MFStdMessage_t);
    	NULL_PTR_DECL;
    
    	MFStdMessage_t(char* p_message, int p_length) 
    		: StdMessage_t(p_message, p_length, MFStdMessage)
    	{
    		// init members here
    	}
    
    	virtual string toString() const
    	{
    		return StdMessage_t::toString("MFStdMessage");
        }

        virtual bool validate() const
        {
            bool good = StdMessage_t::validate() && bodySize() == expectedLength && validateChecksum8ascii();
            return good;
        }

        struct BodyStruct
        {
            Types::a1 id[2];        // JP identifier
            Types::a1 majorVer[2];  // Format major version as decimal (e.g., '01')
            Types::a1 minorVer[2];  // Format minor version as decimal
            Types::a1 order;        // Bytes order
                                    // '0' - LSB first
                                    // '1' - MSB first
            Types::a1 cs[2];        // Checksum formatted as hexadecimal
        };
        VALIDATE_TYPE_SIZE(BodyStruct, 9);
    
    	inline const BodyStruct* bodyStruct() const
        {
            return reinterpret_cast<const BodyStruct*>(body());
        }

        static const int expectedLength = 9;
    protected:
    	/*virtual string bodyToString() const
    	{
    		// return body as string definition
    	}*/
    private:
    	// members here
    };

    /*********************** Time Messages **************************/

    // Receiver Time
    class RTStdMessage_t : public StdMessage_t
    {
    public:
    	SHARED_PTR_T(RTStdMessage_t);
    	NULL_PTR_DECL;
    
    	RTStdMessage_t(char* p_message, int p_length) 
    		: StdMessage_t(p_message, p_length, RTStdMessage)
    	{
    		// init members here
    	}
    
    	virtual string toString() const
    	{
    		return StdMessage_t::toString("RTStdMessage");
    	}
    
    	virtual bool validate() const
    	{
    		bool good = StdMessage_t::validate() && bodySize() == expectedLength && validateChecksum8bin();
    		return good;
        }

        // static consts here
        static const int expectedLength = 5;
    	
    	struct BodyStruct
    	{
            Types::u4 tod; // Tr modulo 1 day (86400000 ms) [ms]
            Types::u1 cs; // Checksum
        };
    	VALIDATE_TYPE_SIZE(BodyStruct, expectedLength);
    	
    	// Member getters here
    	inline const BodyStruct* bodyStruct() const
    	{
    		return reinterpret_cast<const BodyStruct*>(body());
    	}
    protected:
    	/*virtual string bodyToString() const
    	{
    		// return body as string definition
    	}*/
    private:
    	// members here
    };

    /*
    // <Full name>
    class <NAME>StdMessage_t : public StdMessage_t
    {
    public:
        SHARED_PTR_T(<NAME>StdMessage_t);
        NULL_PTR_DECL;

        <NAME>StdMessage_t(char* p_data, int p_length) : StdMessage_t(<NAME>, p_length, <NAME>StdMessage)
        {
            // init members here
        }

        virtual string toString() const
        {
            return StdMessage_t::toString("<NAME>StdMessage");
        }

        // Member getters here

        // static consts here
    protected:
        virtual string bodyToString() const
        {
            // return body as string definition
        }
    private:
        // members here
    };
    */

    class StdMessageFactory_t
    {
    public:
        static StdMessage_t::Pointer_t Create(char* p_message, int p_length)
        {
            EMessageType id = idToEnumMap(p_message);
            switch(id)
            {
            case JPStdMessage:
                return JPStdMessage_t::Pointer_t(new JPStdMessage_t(p_message, p_length));
            case MFStdMessage:
                return MFStdMessage_t::Pointer_t(new MFStdMessage_t(p_message, p_length));
            case RTStdMessage:
                return RTStdMessage_t::Pointer_t(new RTStdMessage_t(p_message, p_length));
            case UnknownStdMessage:
                return StdMessage_t::Pointer_t(new StdMessage_t(p_message, p_length));
            default:
                throw Exception("Invalid EMessageType value.");
            }
        }
    private:
        static EMessageType idToEnumMap(char* p_id)
        {
            typedef map<unsigned short,EMessageType> aMapType;
            static aMapType aMap;
            if (aMap.size() == 0)
            {
                aMap[CHAR2_TO_USHORT("JP")] = JPStdMessage;
                aMap[CHAR2_TO_USHORT("MF")] = MFStdMessage;
                aMap[CHAR2_TO_USHORT("~~")] = RTStdMessage;
            }
            aMapType::iterator it = aMap.find(CHAR2_TO_USHORT(p_id));
            return it != aMap.end() ? it->second : UnknownStdMessage;
        }
    };
}

#pragma pack(pop)

//VALIDATE_TYPE_SIZE(Isp2mRecord, 6);

#endif // GreisMessage_h__

{GreisMessageStream.h}

#ifndef GreisMessageStream_h__
#define GreisMessageStream_h__

#include <QtCore/QtCore>
#include "Common/Util/File.h"
#include "Common/Log/Log.h"
#include <string>
#include "GreisException.h"

using std::string;

namespace Greis
{
    class StdMessageStream
    {
    public:
        StdMessageStream(QString filename)
        {
            Open(filename);
        }

        bool HasNext()
        {
            return _file->peek(1).size() > 0;
        }

        Message_t::Pointer_t Next(bool skipInvalid = false, bool skipNonStd = true)
        {
NextLabel: // avoiding stack overflow in recursive call
            const int minNSTM = NonStdTextMessage_t::min_id;
            const int maxNSTM = NonStdTextMessage_t::max_id;
            const int minSM = StdMessage_t::min_id_char;
            const int maxSM = StdMessage_t::max_id_char;
            char id;
            Message_t::Pointer_t nullPtr = Message_t::null_ptr;
            int readed = _file->peek(&id, 1);

            if (readed == 0)
            {
                // End of file
                return nullPtr;
            }

            if (id >= minNSTM && id <= maxNSTM)
            {
                // Non-standard Text Message
                _file->read(&id, 1);
                char ch;
                char eom = 0;
                string body;
                while (_file->read(&ch, 1) == 1)
                {
                    if (NonStdTextMessage_t::isEom(ch))
                    {
                        // end of message
                        eom = ch;
                        break;
                    }
                    body.push_back(ch);
                }
                if (eom == 0)
                {
                    // Файл закончился до появления eom символа
                    sLog.addWarning(QString("Unexpected end of file, readed %1 body bytes of non-standard text message, expected EOM.").arg(body.size()));
                    return nullPtr;
                }
                NonStdTextMessage_t::Pointer_t msg = NonStdTextMessage_t::Pointer_t(new NonStdTextMessage_t(id, body, eom));
                //sLog.addInfo(msg->toString());
                if (skipNonStd)
                    goto NextLabel;
                else
                    return msg;
            } else if (id == '\r' || id == '\n')
            {
                // Zero-length non-standard Text Message
                NonStdTextMessage_t::Pointer_t msg = NonStdTextMessage_t::Pointer_t(new NonStdTextMessage_t(id));
                _file->read(&id, 1);
                //sLog.addInfo(msg->toString());
                if (skipNonStd)
                    goto NextLabel;
                else
                    return msg;
            } else {
                QByteArray header = _file->peek(5);
                if (header.size() == 5)
                {
                    // Standard Message
                    // message id check
                    char id0 = header[0];
                    char id1 = header[1];
                    if (id0 < minSM || id0 > maxSM || id1 < minSM || id1 > maxSM)
                    {
                        _file->read(1);
                        sLog.addWarning(QString("1 byte skipped."));
                        goto NextLabel; // Пробуем всё сначала, пропустив мусор из файла
                    }
                    // message len
                    QString msgLenStr = QString::fromAscii(header.data() + 2, 3);
                    bool good;
                    int msgLen = msgLenStr.toUInt(&good, 16);
                    if (!good)
                    {
                        throw GreisException(QString("Invalid Length field in StdMessage header: '%1'.").arg(msgLenStr));
                    }
                    // message data
                    QByteArray data = _file->read(msgLen + StdMsgHeaderLen);
                    if (data.size() != msgLen + StdMsgHeaderLen)
                    {
                        sLog.addWarning(QString("Unexpected end of file, readed %1 bytes of standard message, expected %2.")
                            .arg(data.size()).arg(msgLen + StdMsgHeaderLen));
                        return nullPtr;
                    }
                    StdMessage_t::Pointer_t msg = StdMessageFactory_t::Create(data.data(), msgLen + StdMsgHeaderLen);
                    if (skipInvalid && !msg->validate())
                    {
                        sLog.addWarning(QString("Invalid message."), QString("Skip this one and look forward."));
                        goto NextLabel;
                    }
                    //sLog.addInfo(msg->toString());
                    return msg;
                } else {
                    // Данные еще есть, но это не Greis-сообщение
                    _file->read(1);
                    sLog.addWarning(QString("Unexpected end of file"), 
                        QString("cant read whole standard message header, readed: %1, expected: 1. Skip 1 byte and try to find Non-standard Text Message.")
                            .arg(header.size()));
                    goto NextLabel; // Пробуем всё сначала, пропустив мусор из файла
                }
            }
        }

    private:
        void Open(QString filename)
        {
            _filename = filename;
            _file = File::OpenReadBinary(_filename);
        }

    private:
        QString _filename;
        FilePtr _file;
        static const int StdMsgHeaderLen = 5;
    };
}

#endif // GreisMessageStream_h__

{GreisTypes.h}

#ifndef GreisTypes_h__
#define GreisTypes_h__

namespace Greis
{
    namespace Types
    {
        // Type Name | Meaning | Length in Bytes
        typedef char a1;            // a1 | ASCII character | 1
        typedef char i1;            // i1 | signed integer | 1
        typedef short i2;           // i2 | signed integer | 2
        typedef int i4;             // i4 | signed integer | 4
        typedef unsigned char u1;   // u1 | unsigned integer | 1
        typedef unsigned short u2;  // u2 | unsigned integer | 2
        typedef unsigned int u4;    // u4 | unsigned integer | 4
        typedef float f4;           // f4 | IEEE-754 single precision floating point | 4
        typedef double f8;          // f8 | IEEE-754 double precision floating point | 8
    }
}

#endif // GreisTypes_h__

{JpsFile.h}

#ifndef JpsFile_h__
#define JpsFile_h__

#include "Common/Util/macros.h"
#include "Common/Util/commonBoost.h"
#include "GreisMessage.h"
#include "GreisMessageStream.h"
#include <list>

using std::list;

namespace Greis
{
    typedef vector<Message_t::Pointer_t> Epoch_t;

    class JpsFile_t
    {
    public:
        SHARED_PTR_T(JpsFile_t);
        NULL_PTR_DECL;

        JpsFile_t(QString aFilename)
        {
            parse(aFilename);
        }

        inline const Epoch_t& header() const { return _header; }
        inline const list<Epoch_t>& body() const { return _body; }
        inline QString filename() const { return _filename; }

        void toBinaryStream(std::ostream& out) const
        {
            foreach(Message_t::Pointer_t msg, header())
            {
                StdMessage_t::Pointer_t stdMsg = boost::shared_dynamic_cast<StdMessage_t>(msg);
                out.write(stdMsg->message(), stdMsg->fullSize());
                out.write("\0\n", 2);
            }
            foreach(Epoch_t epoch, body())
            {
                foreach(Message_t::Pointer_t msg, epoch)
                {
                    StdMessage_t::Pointer_t stdMsg = boost::shared_dynamic_cast<StdMessage_t>(msg);
                    out.write(stdMsg->message(), stdMsg->fullSize());
                    out.write("\0\n", 2);
                }
            }
            out.flush();
        }
    private:
        void parse(QString aFilename)
        {
            _filename = aFilename;
            _header.clear();
            _body.clear();
            StdMessageStream stream(aFilename);
            Message_t::Pointer_t msg;

            // before ~~(RT)
            while((msg = stream.Next(true)).get() && msg->type() != RTStdMessage)
            {
                _header.push_back(msg);
            }
            // epoch contains PM ? header : body
            vector<Message_t::Pointer_t> epoch;
            if (msg.get())
            {
                epoch.push_back(msg);
            }
            // main parsing loop
            bool headerParsed = false;
            while((msg = stream.Next(true)).get())
            {
                if (msg->type() == RTStdMessage)
                {
                    // push
                    bool isHeader = false;
                    if (!headerParsed)
                    {
                        foreach(Message_t::Pointer_t em, epoch)
                        {
                            if (em->type() == UnknownStdMessage && boost::shared_dynamic_cast<StdMessage_t>(em)->id() == "PM")
                            {
                                isHeader = true;
                            }
                        }
                        headerParsed = true;
                    }
                    if (isHeader)
                    {
                        std::copy(epoch.begin(), epoch.end(), std::back_inserter(_header));
                    } else {
                        _body.push_back(epoch);
                    }
                    epoch.clear();
                }
                epoch.push_back(msg);
            }
            // last Epoch
            if (epoch.size() > 0)
            {
                _body.push_back(epoch);
            }
        }

        Epoch_t _header;
        list<Epoch_t> _body;
        QString _filename;
    };
}

#endif // JpsFile_h__

{Connection.h}

#ifndef Connection_h__
#define Connection_h__

#include <QtCore/QtCore>
#include <QtSql/QtSql>
#include <boost/shared_ptr.hpp>
#include "Common/Exceptions/DatabaseException.h"
#include "DatabaseHelper.h"
#include "Common/Settings/Settings.h"
#include "Common/Log/Log.h"

class Connection
{
private:
	QSqlDatabase _db;
	QString _settingsPrefix;
	int _maxAllowedPacket;
	boost::shared_ptr<DatabaseHelper> _dbHelper;
public:
	QString Driver;
	QString DatabaseName;
	QString Username;
	QString Password;
	QString Hostname;
	int Port;

	void Connect()
	{
		if (_db.isOpen())
			return;

		QString escapedHostname = Hostname;
		escapedHostname.replace('.', '_');
		QString connectionName = QString("%1_%2_%3_%4").arg(Username).
			arg(escapedHostname).arg(Port).arg(DatabaseName);
		_db = QSqlDatabase::addDatabase(Driver, connectionName);
		_db.setDatabaseName(DatabaseName);
		_db.setPort(Port);
		_db.setHostName(Hostname);
		_db.setUserName(Username);
		_db.setPassword(Password);
		_db.setConnectOptions(QString("CLIENT_COMPRESS=1"));
		if (!_db.open())
		{
			throw DatabaseException(_db.lastError().text());
		}

		// Получение максимального размера пакета
		_dbHelper = boost::shared_ptr<DatabaseHelper>(new DatabaseHelper(_db));
		_maxAllowedPacket = _dbHelper->ExecuteSingleRowQuery(
			"SHOW VARIABLES LIKE 'max_allowed_packet'").value(1).toInt();
	}

	inline QSqlDatabase& Database() { return _db; }
	inline DatabaseHelper* DbHelper() { return _dbHelper.get(); }
	inline int MaxAllowedPacket() const { return _maxAllowedPacket; }

	static Connection FromSettings(const QString& settingsPrefix)
	{
		Connection ci;
		ci._settingsPrefix = settingsPrefix;
		ci.Driver = sSettings.value(settingsPrefix + ".Driver", "").toString();
		ci.DatabaseName = sSettings.value(settingsPrefix + ".DatabaseName", "").toString();
		ci.Username = sSettings.value(settingsPrefix + ".Username", "").toString();
		ci.Password = sSettings.value(settingsPrefix + ".Password", "").toString();
		ci.Hostname = sSettings.value(settingsPrefix + ".Hostname", "").toString();
		ci.Port = sSettings.value(settingsPrefix + ".Port", 0).toInt();
		return ci;
	}

	void ToSettings()
	{
		sSettings.setValue(_settingsPrefix + ".Driver", Driver);
		sSettings.setValue(_settingsPrefix + ".DatabaseName", DatabaseName);
		sSettings.setValue(_settingsPrefix + ".Username", Username);
		sSettings.setValue(_settingsPrefix + ".Password", Password);
		sSettings.setValue(_settingsPrefix + ".Hostname", Hostname);
		sSettings.setValue(_settingsPrefix + ".Port", Port);
	}
};

#endif // Connection_h__

{DatabaseHelper.h}

#ifndef ExceptionHelper_h__
#define ExceptionHelper_h__

#include <QtCore/QtCore>
#include <QtSql/QtSql>

class DatabaseHelper
{
private:
    QSqlDatabase _db;
public:
    DatabaseHelper(const QSqlDatabase& db) : _db(db)
    {
    }

    static void ThrowIfError(const QSqlQuery& query)
    {
        if (query.lastError().isValid())
        {
            throw DatabaseException(query.lastError().text());
        }
    }

    inline QSqlQuery ExecuteQuery(const QString& queryString)
    {
        return ExecuteQuery(queryString, _db);
    }

    static QSqlQuery ExecuteQuery(const QString& queryString, QSqlDatabase db/* = QSqlDatabase()*/)
    {
        QSqlQuery query(queryString, db);
        ThrowIfError(query);
        return query;
    }

    inline QSqlQuery ExecuteSingleRowQuery(const QString& queryString)
    {
        return ExecuteSingleRowQuery(queryString, _db);
    }

    static QSqlQuery ExecuteSingleRowQuery(const QString& queryString, QSqlDatabase db/* = QSqlDatabase()*/)
    {
        QSqlQuery query = ExecuteQuery(queryString, db);
        if (!query.next())
        {
            throw DatabaseException(QString("Запрос '%1' вернул 0 записей. Ожидалась 1 запись.").arg(queryString));
        }
        return query;
    }

    inline QVariant ExecuteSingleValueQuery(const QString& queryString)
    {
        return ExecuteSingleValueQuery(queryString, _db);
    }

    static QVariant ExecuteSingleValueQuery(const QString& queryString, QSqlDatabase db/* = QSqlDatabase()*/)
    {
        QSqlQuery query = ExecuteSingleRowQuery(queryString, db);
        QVariant value = query.value(0);
        if (!value.isValid())
        {
            throw DatabaseException(QString("Запрос '%1' вернул некорректное значение для index = 0.").arg(queryString));
        }
        return value;
    }
};

#endif // ExceptionHelper_h__

{DataInserter.h}

#ifndef DataInserter_h__
#define DataInserter_h__

#include <QtCore/QtCore>
#include "../Exceptions/Exception.h"
#include "../Log/Log.h"
#include "Connection.h"
#include "DatabaseHelper.h"

class DataInserter
{
    QString _resultInsertQuery;
    QString _insertTemplate;
    int _rowsAdded;
    Connection* _connection;
    DatabaseHelper* _dbHelper;
public:
    // insertTemplate: "INSERT INTO <table name>(<column name> [<column name>]) VALUES "
    // connection: pointer to connection class
    DataInserter(const QString& insertTemplate, Connection* connection)
    {
        _insertTemplate = insertTemplate;
        _resultInsertQuery = insertTemplate;
        _connection = connection;
        _dbHelper = _connection->DbHelper();
        _rowsAdded = 0;
    }

    // rowValueInBrackets: "(<value for col1> [<value for col #>])"
    void AddRow(const QString& rowValueInBrackets)
    {
        // Выполнение запроса если необходимо
        int resultLength = _resultInsertQuery.count() + rowValueInBrackets.count() + 10;
        if (resultLength > _connection->MaxAllowedPacket())
        {
            Flush();
        }

        if (_rowsAdded == 0)
        {
            _resultInsertQuery.append(" ");
        } else {
            _resultInsertQuery.append(", ");
        }
        _resultInsertQuery = _resultInsertQuery.append(rowValueInBrackets);
        _rowsAdded++;
    }

    // execute all pending queries
    void Flush()
    {
        if (_rowsAdded > 0)
        {
            _dbHelper->ExecuteQuery(ResultQuery());
            _resultInsertQuery = _insertTemplate;
            sLog.addInfo(QString("Добавлено %1 записей...").arg(_rowsAdded));
            _rowsAdded = 0;
        }
    }

    // returns pending query. Throws exception if now row was added till last flush.
    const QString& ResultQuery() const
    {
        if (_rowsAdded == 0)
        {
            throw Exception(QString("Невозможно построить запрос для шаблона %1. Не вставлено ниодной строки.").arg(_resultInsertQuery));
        }

        return _resultInsertQuery;
    }
};

#endif // DataInserter_h__

{DatabaseException.h}

#ifndef DatabaseException_h__
#define DatabaseException_h__

#include <QtCore/QtCore>
#include "Exception.h"

class DatabaseException : public Exception
{
public:
    DatabaseException(const QString& message) : Exception(message)
    {
    }
};

#endif // DatabaseException_h__

{DataStructureException.h}

#ifndef DataStructureException_h__
#define DataStructureException_h__

#include <QtCore/QtCore>
#include "Exception.h"

class DataStructureException : public Exception
{
public:
    DataStructureException(const QString& message) : Exception(message)
    {
    }
};

#endif // DataStructureException_h__

{Exception.h}

#ifndef Exception_h__
#define Exception_h__

class Exception
{
    QString _message;
public:
    Exception(const QString& message)
    {
        _message = message;
    }

    Exception()
    {
    }

    virtual ~Exception()
    {
    }

    virtual QString what() const
    {
        return _message;
    }
};

#endif // Exception_h__

{FileException.h}

#ifndef FileException_h__
#define FileException_h__

#include <QtCore/QtCore>
#include "Exception.h"

class FileException : public Exception
{
public:
    FileException(const QString& message) : Exception(message)
    {
    }
};

#endif // FileException_h__

{InvalidOperationException.h}

#ifndef InvalidOperationException_h__
#define InvalidOperationException_h__

#include <QtCore/QtCore>
#include "Exception.h"

class InvalidOperationException : public Exception
{
public:
    InvalidOperationException(const QString& message) : Exception(message)
    {
    }

    InvalidOperationException()
    {
    }
};

#endif // InvalidOperationException_h__

{Log.h}

#ifndef Log_h__
#define Log_h__

#include <QString>
#include <string>

#include "../Util/singleton.h"

using std::string;

namespace Common
{
    class Log
    {
        SINGLETON_BLOCK(Log)
    public:
        void addError(const QString& message, const QString& details = QString());
        void addWarning(const QString& message, const QString& details = QString());
        void addInfo(const QString& message, const QString& details = QString());
        void addError(const string& message, const string& details = string());
        void addWarning(const string& message, const string& details = string());
        void addInfo(const string& message, const string& details = string());

        void Initialize(bool displayMessages, const QString logFile);
    private:
        bool _displayMessages;
        QString _logFile;
        QTextCodec *_codec;
    private:
        void addToConsole(const QString& message, const QString& details = QString());
        QString asciiToQString(const string& str);
    };
} // Common

#define sLog SINGLETON_INSTANCE(::Common::Log)

#endif // Log_h__


{Settings.h}

#ifndef __SettingsController_h__
#define __SettingsController_h__

#include <QSettings>
#include <QString>
#include "../Util/singleton.h"

namespace Common
{
    class Settings
    {
        SINGLETON_BLOCK(Settings)
    public:
        bool Initialize(const QString& settingsFile);
        void setValue(const QString& key, const QVariant& value);
        QVariant value(const QString & key, const QVariant & defaultValue = QVariant()) const;

        inline QSettings* settings() { return _pSettings; }
    private:
        QSettings* _pSettings;
        QString _settingsFile;
        bool _initialized;
    };
}

#define sSettings SINGLETON_INSTANCE(::Common::Settings)

#endif


{BitConverter.h}

#ifndef BitConverter_h__
#define BitConverter_h__

class BitConverter
{
public:
    inline static unsigned short getUShort(char* data)
    {
        unsigned char* ucdata = reinterpret_cast<unsigned char*>(data);
        return (unsigned short)((*ucdata << 8) + (*(ucdata+1)));
    }

    inline static unsigned int getUInt(char* data)
    {
        unsigned int value = *reinterpret_cast<unsigned int*>(data);
        endian_swap(value);
        return value;
    }

    inline static void endian_swap(unsigned short& x)
    {
        x = (unsigned short)
            ((x>>8) | 
             (x<<8));
    }

    inline static void endian_swap(unsigned int& x)
    {
        x = (x>>24) | 
            ((x<<8) & 0x00FF0000) |
            ((x>>8) & 0x0000FF00) |
            (x<<24);
    }

    // __int64 for MSVC, "long long" for gcc
    inline static void endian_swap(unsigned long long& x)
    {
        x = (x>>56) | 
            ((x<<40) & 0x00FF000000000000) |
            ((x<<24) & 0x0000FF0000000000) |
            ((x<<8)  & 0x000000FF00000000) |
            ((x>>8)  & 0x00000000FF000000) |
            ((x>>24) & 0x0000000000FF0000) |
            ((x>>40) & 0x000000000000FF00) |
            (x<<56);
    }
};

#endif // BitConverter_h__


{commonBoost.h}

#ifndef commonBoost_h__
#define commonBoost_h__

// foreach
//#include <boost/foreach.hpp>

//#define foreach BOOST_FOREACH

// format
/* USAGE:
 * cout << format("%1% %2% %3% %2% %1% \n") % "11" % "22" % "333"; // 'simple' style.
 * OR
 * cout << format("writing %s,  x=%s : %d-th step \n") % "toto" % 40.23 % 50;
 * OR
 * string msg = str( boost::format("Debug message %s") % some_msg_string );
 * OR
 * cout << format("(x,y) = (%1$+5d,%2$+5d) \n") % -23 % 35;     // Posix-Printf style
*/
#include <boost/format.hpp>

using boost::format;
using boost::wformat;
using boost::str;

// shared_ptr

#include <boost/shared_ptr.hpp>

#define SHARED_PTR_T(t) typedef boost::shared_ptr<##t> Pointer_t;
#define SHARED_PTR_CREATE(t) t::Pointer_t(new t());
#define NULL_PTR_DECL static const Pointer_t null_ptr;
#define NULL_PTR_IMPL(t) const t::Pointer_t t::null_ptr = t::Pointer_t();

#endif // commonBoost_h__

{File.h}

#ifndef File_h__
#define File_h__

#include "../Exceptions/FileException.h"
#include <boost/shared_ptr.hpp>

typedef boost::shared_ptr<QFile> FilePtr;

class File
{
public:
    // Открытие файла на чтение в бинарном виде. Ошибка если файла нет.
    static FilePtr OpenReadBinary(QString filename)
    {
        FilePtr file(new QFile(filename));
        if (!file->open(QIODevice::ReadOnly))
        {
            throw FileException(QString("Ошибка при открытии файла '%1': %2.").arg(filename).arg(file->errorString()));
        }
        return file;
    }
};

#endif // File_h__


{macros.h}

#ifndef macros_h__
#define macros_h__

#include <boost/static_assert.hpp>

/**** helper macros ****/

/* turn a numeric literal into a hex constant
(avoids problems with leading zeroes)
8-bit constants max value 0x11111111, always fits in unsigned long
*/
#define HEX__(n) 0x##n##LU

/* 8-bit conversion function */
#define B8__(x) ((x&0x0000000FLU)?1:0) \
	+((x&0x000000F0LU)?2:0) \
	+((x&0x00000F00LU)?4:0) \
	+((x&0x0000F000LU)?8:0) \
	+((x&0x000F0000LU)?16:0) \
	+((x&0x00F00000LU)?32:0) \
	+((x&0x0F000000LU)?64:0) \
	+((x&0xF0000000LU)?128:0)

/* *** user macros *** */

/* for upto 8-bit binary constants */
#define B8(d) ((unsigned char)B8__(HEX__(d)))

/* for upto 16-bit binary constants, MSB first */
#define B16(dmsb,dlsb) (((unsigned short)B8(dmsb)<< \
	+ B8(dlsb))

/* for upto 32-bit binary constants, MSB first */
#define B32(dmsb,db2,db3,dlsb) (((unsigned long)B8(dmsb)<<24) \
	+ ((unsigned long)B8(db2)<<16) \
	+ ((unsigned long)B8(db3)<< \
	+ B8(dlsb))

#define VALIDATE_TYPE_SIZE(TYPENAME, EXPECTEDSIZE) BOOST_STATIC_ASSERT(sizeof(TYPENAME) == EXPECTEDSIZE/*, "The size of "#TYPENAME" is incorrect"*/)

#endif // macros_h__


{singleton.h}

#ifndef SINGLETON_H
#define SINGLETON_H

//#define MT_SUPPORT_BOOST
#define SHAREDPTR_QT

#ifdef SHAREDPTR_BOOST
#include <boost/shared_ptr.hpp>
#endif
#ifdef SHAREDPTR_QT
#include <QSharedPointer>
#endif
#ifdef MT_SUPPORT_BOOST
#include <boost/thread/thread.hpp>
#endif

namespace Common
{
    template<class T>
    class Singleton
    {
    public:
        static T& Instance()
        {
#ifdef MT_SUPPORT_BOOST
            static boost::mutex _mutex;
            boost::mutex::scoped_lock scoped_lock(_mutex);
#endif
#ifdef SHAREDPTR_BOOST
            static boost::shared_ptr<T> _impl;
            if (!_impl.get())
            {
                _impl.reset(new T);
            }
            return *_impl.get();
#endif
#ifdef SHAREDPTR_QT
            static QSharedPointer<T> _impl;
            if (_impl.isNull())
            {
                _impl = QSharedPointer<T>(new T);
            }
            return *_impl;
#endif
        }
    private:
        Singleton(const Singleton&);
        Singleton& operator=(const Singleton&);
    };
} // Common

#define SINGLETON_BLOCK(ClassName)\
public:\
    virtual ~ClassName();\
protected:\
    friend class ::Common::Singleton<ClassName>;\
    ClassName();\
    ClassName(ClassName const&) {}\
    ClassName inline& operator=(ClassName const&) { return *this; }\
private:

#define SINGLETON_INSTANCE(ClassName) ::Common::Singleton<ClassName>::Instance()

#endif // SINGLETON_H


{GreisMessage.cpp}

#include "GreisMessage.h"

namespace Greis
{
    NULL_PTR_IMPL(Message_t);

    NULL_PTR_IMPL(NonStdTextMessage_t);

    NULL_PTR_IMPL(StdMessage_t);

    NULL_PTR_IMPL(JPStdMessage_t);
    const string JPStdMessage_t::javadGnssId = "RLOGF";
    const string JPStdMessage_t::javadGnssDescriptionFormat = "JPS $ReceiverName$ Receiver log-file";
}


{JpsFile.cpp}

#include "JpsFile.h"

namespace Greis
{
    NULL_PTR_IMPL(JpsFile_t);
}


{main.cpp}

#include <QtCore/QtCore>
#include <iostream>
#include <clocale>
#include <locale>
#include "Common/Exceptions/Exception.h"
#include "Common/Log/Log.h"
#include "Common/Settings/Settings.h"

#include "GreisMessage.h"
#include "GreisMessageStream.h"
#include "JpsFile.h"
#include "Common/Exceptions/FileException.h"
#include "DatabaseWriter.h"

#include <fstream>
#include <algorithm>

using namespace std;
using namespace Greis;

int main(int argc, char *argv[])
{
    try
    {
        std::setlocale(LC_ALL, "Russian_Russia.1251");
        std::locale::global(std::locale("Russian_Russia.1251"));

        QCoreApplication a(argc, argv);

        // кодеки
        QTextCodec* codec = QTextCodec::codecForName("UTF-8");
        QTextCodec* codecMs = QTextCodec::codecForName("Windows-1251");
        QTextCodec::setCodecForCStrings(codecMs);
        QTextCodec::setCodecForLocale(codec);
        QTextCodec::setCodecForTr(codec);

        sLog.Initialize(false, QCoreApplication::applicationDirPath() + "/converter.log");
        sSettings.Initialize(QCoreApplication::applicationDirPath() + "/config.ini");
        QStringList args = a.arguments();

        if (args.count() < 2)
        {
            sLog.addError(QString("Invalid command line arguments. Usage: JpsParser <input Jps file>"));
            return 1;
        }
        QString filename = args[1];

#ifdef _DEBUG
        {
            string log1;
            StdMessageStream stream(filename);
            Message_t::Pointer_t msg;
            while((msg = stream.Next(true)).get())
            {
                log1.append(boost::shared_dynamic_cast<StdMessage_t>(msg)->id() + " ");
            }
            std::ofstream fileLog("jpsTrace.txt");
            fileLog.write(log1.c_str(), log1.size());
            fileLog.close();
        }
#endif

        // Открытие и парсинг
        JpsFile_t::Pointer_t jpsFile(new JpsFile_t(filename));
        // Запись в базу
        /*Connection connection = Connection::FromSettings("Db");
        DatabaseWriter writer;
        writer.Connect(connection, "source1");
        writer.AddData(jpsFile);*/

#ifdef _DEBUG
        std::ofstream jps2("jps2.jps");
        jpsFile->toBinaryStream(jps2);
        jps2.close();
#endif

d2        system("PAUSE");
        return 0;
    }
    catch (Exception& e)
    {
        sLog.addError(e.what());
        return 1;
    }
}


{Log.cpp}

#include "Log.h"

#include <QtGui/QMessageBox>
#include <QtCore/QTextStream>
#include <QtCore/QTextCodec>
#include <QtCore/QDebug>
#include <QtCore/QDateTime>
#include <iostream>
#include <string>

using namespace std;

namespace Common
{
    Log::Log()
    {
#ifdef WIN32
        _codec = QTextCodec::codecForName("IBM 866");
#else
        // TODO: РєР°РєРѕР№ РєРѕРґРµРє РІ Р»РёРЅСѓС…-РєРѕРЅСЃРѕР»Рµ?
        _codec = QTextCodec::codecForName("UTF-8");
#endif
    }

    Log::~Log()
    {
    }

    void Log::addError( const QString& message, const QString& details )
    {
        addToConsole(message, details);
        //QMessageBox::critical(0, shortMessage, message);
    }
    void Log::addWarning( const QString& message, const QString& details )
    {
        addToConsole(message, details);
        //QMessageBox::warning(0, QString::fromUtf8("Р’РЅРёРјР°РЅРёРµ!"), message);
    }

    void Log::addInfo( const QString& message, const QString& details )
    {
        addToConsole(message, details);
    }

    void Log::addError( const string& message, const string& details )
    {
        addError(asciiToQString(message), asciiToQString(details));
    }
    void Log::addWarning( const string& message, const string& details )
    {
        addWarning(asciiToQString(message), asciiToQString(details));
    }

    void Log::addInfo( const string& message, const string& details )
    {
        addInfo(asciiToQString(message), asciiToQString(details));
    }

    void Log::Initialize( bool displayMessages, const QString logFile )
    {
        _displayMessages = displayMessages;
        _logFile = logFile;
    }

    void Log::addToConsole( const QString& message, const QString& details )
    {
        QDateTime currentTime = QDateTime::currentDateTime();
        //QString prefix = currentTime.toString("dd.MM.yyyy hh:mm:ss: ");
        QString prefix = currentTime.toString("hh:mm:ss: ");
        QByteArray encodedPrefix = _codec->fromUnicode(prefix);
        QByteArray encodedMessage = _codec->fromUnicode(message);
        cout << (const char*)encodedPrefix << (const char*)encodedMessage << endl;
        if (!details.isEmpty())
        {
            QByteArray encodedDetails = _codec->fromUnicode(QString("Details: ") + details);
            cout << (const char*)encodedDetails << endl;
        }
    }

    QString Log::asciiToQString( const string& str )
    {
        return QString::fromAscii(str.c_str(), str.size());
    }
}


{Settings.cpp}

#include "Settings.h"
#include "../Log/Log.h"
#include <QCoreApplication>
#include <QDir>
#include <QFile>
#include <QTextStream>
#include <QRegExp>
#include <QMap>
#include <QTextCodec>

namespace Common
{
    Settings::Settings()
    {
        _pSettings = 0;
    }

    Settings::~Settings()
    {
        if (_pSettings)
            delete _pSettings;
    }

    bool Settings::Initialize(const QString& settingsFile)
    {
        _settingsFile = settingsFile;
        _pSettings = new QSettings(_settingsFile, QSettings::IniFormat);
        _initialized = true;
        return true;
    }

    void Settings::setValue( const QString& key, const QVariant& value )
    {
        _pSettings->setValue(key, value);
    }

    QVariant Settings::value( const QString & key, const QVariant & defaultValue /*= QVariant()*/ ) const
    {
        return _pSettings->value(key, defaultValue);
    }
}


